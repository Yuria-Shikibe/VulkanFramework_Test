#version 460
#pragma shader_stage(compute)
#extension GL_ARB_separate_shader_objects: enable

#include "lib/util"

layout (local_size_x = 16, local_size_y = 16) in;

// Normal filtered anti-aliasing.
// See http://blenderartists.org/forum/showthread.php?209574-Full-Screen-Anti-Aliasing-(NFAA-DLAA-SSAA)
// and http://www.gamedev.net/topic/580517-nfaa---a-post-process-anti-aliasing-filter-results-implementation-details/
// Copyright Styves, Martinsh
// Modified by Sagrista, Toni

layout (binding = 0) uniform sampler2D inputImage;
layout (binding = 1) writeonly uniform image2D outputImage;


const float fScale = 1.5f;

vec4 nfaa(sampler2D tex, ivec2 srcPos, vec2 texCoords, vec2 uvStep) {
    // Offset coordinates

    vec2 upOffset = vec2(0.0, uvStep.y) * fScale;
    vec2 rightOffset = vec2(uvStep.x, 0.0) * fScale;

    float topHeight = lumRGB(texture(tex, texCoords.xy + upOffset).rgb);
    float bottomHeight = lumRGB(texture(tex, texCoords.xy - upOffset).rgb);
    float rightHeight = lumRGB(texture(tex, texCoords.xy + rightOffset).rgb);
    float leftHeight = lumRGB(texture(tex, texCoords.xy - rightOffset).rgb);
    float leftTopHeight = lumRGB(texture(tex, texCoords.xy - rightOffset + upOffset).rgb);
    float leftBottomHeight = lumRGB(texture(tex, texCoords.xy - rightOffset - upOffset).rgb);
    float rightBottomHeight = lumRGB(texture(tex, texCoords.xy + rightOffset + upOffset).rgb);
    float rightTopHeight = lumRGB(texture(tex, texCoords.xy + rightOffset - upOffset).rgb);

    // Normal map creation
    float sum0 = rightTopHeight + topHeight + rightBottomHeight;
    float sum1 = leftTopHeight + bottomHeight + leftBottomHeight;
    float sum2 = leftTopHeight + leftHeight + rightTopHeight;
    float sum3 = leftBottomHeight + rightHeight + rightBottomHeight;
    float vect1 = (sum1 - sum0);
    float vect2 = (sum2 - sum3);

    // Put them together and scale.
    vec2 Normal = vec2(vect1, vect2) * uvStep * fScale;

    // Color
    vec4 scene0 = texelFetch(tex, srcPos, 0);
    vec4 scene1 = texture(tex, texCoords + Normal);
    vec4 scene2 = texture(tex, texCoords - Normal);
    vec4 scene3 = texture(tex, texCoords + vec2(Normal.x, -Normal.y) * 0.5);
    vec4 scene4 = texture(tex, texCoords - vec2(Normal.x, -Normal.y) * 0.5);

    return vec4((scene0.rgb + scene1.rgb + scene2.rgb + scene3.rgb + scene4.rgb) * 0.2, scene0.a);
    //    return vec4(Normal.xy * 5, scene0.a, scene0.a);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 norstep = vec2(1) / vec2(imageSize(outputImage));
    vec2 uv = (vec2(pos) + vec2(0.5f, 0.5f)) * norstep;

    vec4 color = nfaa(inputImage, pos, uv, norstep);
    imageStore(outputImage, pos, color);
}
/**

const float oneThird = 1.0 / 3.0;

float favg(vec3 vec){
    return (vec.x + vec.y + vec.z) * oneThird;
}

vec4 sampleOffseted(const sampler2D tex, const vec2 texCoord, const vec2 pixelOffset, const vec2 norStep) {
    return texture(tex, texCoord + pixelOffset * norStep);
}

vec3 avg(const in vec3 value)
{
    return dot(value.xyz, vec3(oneThird, oneThird, oneThird));
}

vec4 firsPassEdgeDetect(vec2 texCoord, const vec2 norStep)
{
vec4 sCenter = sampleOffseted(inputImage, texCoord, vec2(0.0, 0.0), norStep);
vec4 sUpLeft = sampleOffseted(inputImage, texCoord, vec2(- 0.5, - 0.5), norStep);
vec4 sUpRight = sampleOffseted(inputImage, texCoord, vec2(0.5, -0.5), norStep);
vec4 sDownLeft = sampleOffseted(inputImage, texCoord, vec2(- 0.5, 0.5), norStep);
vec4 sDownRight = sampleOffseted(inputImage, texCoord, vec2(0.5, 0.5), norStep);

vec4 diff = abs(((sUpLeft + sUpRight + sDownLeft + sDownRight) * 4.0) - (sCenter * 16.0));
float edgeMask = favg(diff.xyz) * oneThird;

return vec4(sCenter.rgb, edgeMask);
}


vec4 secondPassEdgeDetectAndBlur(vec2 texCoord, const vec2 norStep) {
    // short edges
    vec4 sampleCenter = sampleOffseted(inputImage, texCoord, vec2(0.0, 0.0), norStep);
    vec4 sampleHorizNeg0 = sampleOffseted(inputImage, texCoord, vec2(- 1.5, 0.0), norStep);
    vec4 sampleHorizPos0 = sampleOffseted(inputImage, texCoord, vec2(1.5, 0.0), norStep);
    vec4 sampleVertNeg0 = sampleOffseted(inputImage, texCoord, vec2(0.0, - 1.5), norStep);
    vec4 sampleVertPos0 = sampleOffseted(inputImage, texCoord, vec2(0.0, 1.5), norStep);
    
    vec4 sumHoriz = sampleHorizNeg0 + sampleHorizPos0;
    vec4 sumVert = sampleVertNeg0 + sampleVertPos0;
    
    vec4 diffToCenterHoriz = abs(sumHoriz - (2.0 * sampleCenter)) / 2.0;
    vec4 diffToCenterVert = abs(sumHoriz - (2.0 * sampleCenter)) / 2.0;
    
    float valueEdgeHoriz = favg(diffToCenterHoriz.xyz);
    float valueEdgeVert = favg(diffToCenterVert.xyz);
    
    float edgeDetectHoriz = clamp((3.0 * valueEdgeHoriz) - 0.1, 0., 1.);
    float edgeDetectVert = clamp((3.0 * valueEdgeVert) - 0.1, 0., 1.);
    
    vec4 avgHoriz = (sumHoriz + sampleCenter) / 3.0;
    vec4 avgVert = (sumVert + sampleCenter) / 3.0;
    
    float valueHoriz = favg(avgHoriz.xyz);
    float valueVert = favg(avgVert.xyz);
    
    float blurAmountHoriz = clamp(edgeDetectHoriz / valueHoriz, 0., 1.);
    float blurAmountVert = clamp(edgeDetectVert / valueVert, 0., 1.);
    
    vec4 aaResult = mix(sampleCenter, avgHoriz, blurAmountHoriz);
    aaResult = mix(aaResult, avgVert, blurAmountVert);
    
    // long edges
    vec4 sampleVertNeg1 = sampleOffseted(inputImage, texCoord, vec2(0.0, - 3.5), norStep);
    vec4 sampleVertNeg2 = sampleOffseted(inputImage, texCoord, vec2(0.0, - 7.5), norStep);
    vec4 sampleVertPos1 = sampleOffseted(inputImage, texCoord, vec2(0.0, 3.5), norStep);
    vec4 sampleVertPos2 = sampleOffseted(inputImage, texCoord, vec2(0.0, 7.5), norStep);
    
    vec4 sampleHorizNeg1 = sampleOffseted(inputImage, texCoord, vec2(- 3.5, 0.0), norStep);
    vec4 sampleHorizNeg2 = sampleOffseted(inputImage, texCoord, vec2(- 7.5, 0.0), norStep);
    vec4 sampleHorizPos1 = sampleOffseted(inputImage, texCoord, vec2(3.5, 0.0), norStep);
    vec4 sampleHorizPos2 = sampleOffseted(inputImage, texCoord, vec2(7.5, 0.0), norStep);
    
    float pass1EdgeAvgHoriz = (sampleHorizNeg2.a + sampleHorizNeg1.a + sampleCenter.a + sampleHorizPos1.a + sampleHorizPos2.a) / 5.0;
    float pass1EdgeAvgVert = (sampleVertNeg2.a + sampleVertNeg1.a + sampleCenter.a + sampleVertPos1.a + sampleVertPos2.a) / 5.0;
    pass1EdgeAvgHoriz = clamp( pass1EdgeAvgHoriz * 2.0f - 1.0f, 0., 1.);
    pass1EdgeAvgVert = clamp(pass1EdgeAvgVert * 2.0f - 1.0f, 0., 1.);
    float longEdge = max(pass1EdgeAvgHoriz, pass1EdgeAvgVert);
    
    if (longEdge > 0) {
        vec4 avgHorizLong = (sampleHorizNeg2 + sampleHorizNeg1 + sampleCenter + sampleHorizPos1 + sampleHorizPos2) / 5.0;
        vec4 avgVertLong = (sampleVertNeg2 + sampleVertNeg1 + sampleCenter + sampleVertPos1 + sampleVertPos2 ) / 5.0;
        float valueHorizLong = favg(avgHorizLong.xyz);
        float valueVertLong = favg(avgVertLong.xyz);
        
        vec4 sampleLeft = sampleOffseted(inputImage, texCoord, vec2(- 1.0, 0.0), norStep);
        vec4 sampleRight = sampleOffseted(inputImage, texCoord, vec2(1.0, 0.0), norStep);
        vec4 sampleUp = sampleOffseted(inputImage, texCoord, vec2(0.0, - 1.0), norStep);
        vec4 sampleDown = sampleOffseted(inputImage, texCoord, vec2(0.0, 1.0), norStep);
        
        float valueCenter = favg(sampleCenter.xyz);
        float valueLeft = favg(sampleLeft.xyz);
        float valueRight = favg(sampleRight.xyz);
        float valueTop = favg(sampleUp.xyz);
        float valueBottom = favg(sampleDown.xyz);
        
        vec4 diffToCenter = valueCenter - vec4(valueLeft, valueTop, valueRight, valueBottom);
        float blurAmountLeft = clamp(0.0 + (valueVertLong - valueLeft) / diffToCenter.x, 0., 1.);
        float blurAmountUp = clamp(0.0 + (valueHorizLong - valueTop) / diffToCenter.y, 0., 1.);
        float blurAmountRight = clamp(1.0 + (valueVertLong - valueCenter) / diffToCenter.z, 0., 1.);
        float blurAmountDown = clamp(1.0 + ( valueHorizLong - valueCenter) / diffToCenter.w, 0., 1.);
        
        vec4 blurAmounts = vec4(blurAmountLeft, blurAmountRight, blurAmountUp, blurAmountDown);
        blurAmounts = (blurAmounts == vec4(0.0, 0.0, 0.0, 0.0)) ? vec4(1.0, 1.0, 1.0, 1.0): blurAmounts;
        
        vec4 longBlurHoriz = mix(sampleLeft, sampleCenter, blurAmounts.x);
        longBlurHoriz = mix(sampleRight, longBlurHoriz, blurAmounts.y);
        vec4 longBlurVert = mix(sampleUp, sampleCenter, blurAmounts.z);
        longBlurVert = mix(sampleDown, longBlurVert, blurAmounts.w);
        
        aaResult = mix(aaResult, longBlurHoriz, pass1EdgeAvgVert);
        aaResult = mix(aaResult, longBlurVert, pass1EdgeAvgHoriz);
        }
    
    return vec4(aaResult.rgb, 1.0f);
}
*/
