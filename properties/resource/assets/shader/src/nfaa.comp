#version 460
#pragma shader_stage(compute)
#extension GL_ARB_separate_shader_objects : enable

#include "lib/util"

layout (local_size_x = 16, local_size_y = 16) in;

// Normal filtered anti-aliasing.
// See http://blenderartists.org/forum/showthread.php?209574-Full-Screen-Anti-Aliasing-(NFAA-DLAA-SSAA)
// and http://www.gamedev.net/topic/580517-nfaa---a-post-process-anti-aliasing-filter-results-implementation-details/
// Copyright Styves, Martinsh
// Modified by Sagrista, Toni

layout (binding = 0) uniform sampler2D inputImage;
layout (binding = 1) writeonly uniform image2D outputImage;


const float fScale = 1.5f;

vec4 nfaa(sampler2D tex, ivec2 srcPos, vec2 texCoords, vec2 uvStep) {
    // Offset coordinates

    vec2 upOffset = vec2(0.0, uvStep.y) * fScale;
    vec2 rightOffset = vec2(uvStep.x, 0.0) * fScale;

    float topHeight = lumRGB(texture(tex, texCoords.xy + upOffset).rgb);
    float bottomHeight = lumRGB(texture(tex, texCoords.xy - upOffset).rgb);
    float rightHeight = lumRGB(texture(tex, texCoords.xy + rightOffset).rgb);
    float leftHeight = lumRGB(texture(tex, texCoords.xy - rightOffset).rgb);
    float leftTopHeight = lumRGB(texture(tex, texCoords.xy - rightOffset + upOffset).rgb);
    float leftBottomHeight = lumRGB(texture(tex, texCoords.xy - rightOffset - upOffset).rgb);
    float rightBottomHeight = lumRGB(texture(tex, texCoords.xy + rightOffset + upOffset).rgb);
    float rightTopHeight = lumRGB(texture(tex, texCoords.xy + rightOffset - upOffset).rgb);

    // Normal map creation
    float sum0 = rightTopHeight + topHeight + rightBottomHeight;
    float sum1 = leftTopHeight + bottomHeight + leftBottomHeight;
    float sum2 = leftTopHeight + leftHeight + rightTopHeight;
    float sum3 = leftBottomHeight + rightHeight + rightBottomHeight;
    float vect1 = (sum1 - sum0);
    float vect2 = (sum2 - sum3);

    // Put them together and scale.
    vec2 Normal = vec2(vect1, vect2) * uvStep * fScale;

    // Color
    vec4 scene0 = texelFetch(tex, srcPos, 0);
    vec4 scene1 = texture(tex, texCoords + Normal);
    vec4 scene2 = texture(tex, texCoords - Normal);
    vec4 scene3 = texture(tex, texCoords + vec2(Normal.x, -Normal.y) * 0.5);
    vec4 scene4 = texture(tex, texCoords - vec2(Normal.x, -Normal.y) * 0.5);

    return vec4((scene0.rgb + scene1.rgb + scene2.rgb + scene3.rgb + scene4.rgb) * 0.2, scene0.a);
    //    return vec4(Normal.xy * 5, scene0.a, scene0.a);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 norstep = vec2(1) / vec2(imageSize(outputImage));
    vec2 uv = (vec2(pos) + vec2(0.5f, 0.5f)) * norstep;

    vec4 color = nfaa(inputImage, pos, uv, norstep);
    imageStore(outputImage, pos, color);
}

/*

#define PIXEL_SIZE float2(1.0/1280, 1.0/720)

float4 sampleOffseted(const in sampler2D tex, const in float2 texCoord, const float2 pixelOffset )
{
return tex2D(tex, texCoord + pixelOffset * PIXEL_SIZE);
}

float3 avg(const in float3 value)
{
static const float oneThird = 1.0 / 3.0;
return dot(value.xyz, float3(oneThird, oneThird, oneThird) );
}

float4 firsPassEdgeDetect( float2 texCoord : TEXCOORD0 ) : COLOR
{
float4 sCenter = sampleOffseted(Texture0, texCoord, float2( 0.0, 0.0) );
float4 sUpLeft = sampleOffseted(Texture0, texCoord, float2(-0.5, -0.5) );
float4 sUpRight = sampleOffseted(Texture0, texCoord, float2( 0.5, -0.5) );
float4 sDownLeft = sampleOffseted(Texture0, texCoord, float2(-0.5, 0.5) );
float4 sDownRight = sampleOffseted(Texture0, texCoord, float2( 0.5, 0.5) );

float4 diff = abs( ((sUpLeft + sUpRight + sDownLeft + sDownRight) * 4.0) - (sCenter * 16.0) );
float edgeMask = avg(diff.xyz);

return float4(sCenter.rgb, edgeMask);
}


float4 secondPassEdgeDetectAndBlur( float2 texCoord : TEXCOORD0 ) : COLOR
{
// short edges
float4 sampleCenter = sampleOffseted(Texture0, texCoord.xy, float2( 0.0, 0.0) );
float4 sampleHorizNeg0 = sampleOffseted(Texture0, texCoord.xy, float2(-1.5, 0.0) );
float4 sampleHorizPos0 = sampleOffseted(Texture0, texCoord.xy, float2( 1.5, 0.0) );
float4 sampleVertNeg0 = sampleOffseted(Texture0, texCoord.xy, float2( 0.0, -1.5) );
float4 sampleVertPos0 = sampleOffseted(Texture0, texCoord.xy, float2( 0.0, 1.5) );

float4 sumHoriz = sampleHorizNeg0 + sampleHorizPos0;
float4 sumVert = sampleVertNeg0 + sampleVertPos0;

float4 diffToCenterHoriz = abs( sumHoriz - (2.0 * sampleCenter) ) / 2.0;
float4 diffToCenterVert = abs( sumHoriz - (2.0 * sampleCenter) ) / 2.0;

float valueEdgeHoriz = avg( diffToCenterHoriz.xyz );
float valueEdgeVert = avg( diffToCenterVert.xyz );

float edgeDetectHoriz = saturate( (3.0 * valueEdgeHoriz) - 0.1);
float edgeDetectVert = saturate( (3.0 * valueEdgeVert) - 0.1);

float4 avgHoriz = ( sumHoriz + sampleCenter) / 3.0;
float4 avgVert = ( sumVert + sampleCenter) / 3.0;

float valueHoriz = avg( avgHoriz.xyz );
float valueVert = avg( avgVert.xyz );

float blurAmountHoriz = saturate( edgeDetectHoriz / valueHoriz );
float blurAmountVert = saturate( edgeDetectVert / valueVert );

float4 aaResult = lerp( sampleCenter, avgHoriz, blurAmountHoriz );
aaResult = lerp( aaResult, avgVert, blurAmountVert );

// long edges
float4 sampleVertNeg1 = sampleOffseted(Texture0, texCoord.xy, float2(0.0, -3.5) );
float4 sampleVertNeg2 = sampleOffseted(Texture0, texCoord.xy, float2(0.0, -7.5) );
float4 sampleVertPos1 = sampleOffseted(Texture0, texCoord.xy, float2(0.0, 3.5) );
float4 sampleVertPos2 = sampleOffseted(Texture0, texCoord.xy, float2(0.0, 7.5) );

float4 sampleHorizNeg1 = sampleOffseted(Texture0, texCoord.xy, float2(-3.5, 0.0) );
float4 sampleHorizNeg2 = sampleOffseted(Texture0, texCoord.xy, float2(-7.5, 0.0) );
float4 sampleHorizPos1 = sampleOffseted(Texture0, texCoord.xy, float2( 3.5, 0.0) );
float4 sampleHorizPos2 = sampleOffseted(Texture0, texCoord.xy, float2( 7.5, 0.0) );

float pass1EdgeAvgHoriz = ( sampleHorizNeg2.a + sampleHorizNeg1.a + sampleCenter.a + sampleHorizPos1.a + sampleHorizPos2.a ) / 5.0;
float pass1EdgeAvgVert = ( sampleVertNeg2.a + sampleVertNeg1.a + sampleCenter.a + sampleVertPos1.a + sampleVertPos2.a ) / 5.0;
pass1EdgeAvgHoriz = saturate( pass1EdgeAvgHoriz * 2.0f - 1.0f );
pass1EdgeAvgVert = saturate( pass1EdgeAvgVert * 2.0f - 1.0f );
float longEdge = max( pass1EdgeAvgHoriz, pass1EdgeAvgVert);

if ( longEdge > 0 )
{
float4 avgHorizLong = ( sampleHorizNeg2 + sampleHorizNeg1 + sampleCenter + sampleHorizPos1 + sampleHorizPos2 ) / 5.0;
float4 avgVertLong = ( sampleVertNeg2 + sampleVertNeg1 + sampleCenter + sampleVertPos1 + sampleVertPos2 ) / 5.0;
float valueHorizLong = avg(avgHorizLong.xyz);
float valueVertLong = avg(avgVertLong.xyz);

float4 sampleLeft = sampleOffseted(Texture0, texCoord.xy, float2(-1.0, 0.0) );
float4 sampleRight = sampleOffseted(Texture0, texCoord.xy, float2( 1.0, 0.0) );
float4 sampleUp = sampleOffseted(Texture0, texCoord.xy, float2( 0.0, -1.0) );
float4 sampleDown = sampleOffseted(Texture0, texCoord.xy, float2( 0.0, 1.0) );

float valueCenter = avg(sampleCenter.xyz);
float valueLeft = avg(sampleLeft.xyz);
float valueRight = avg(sampleRight.xyz);
float valueTop = avg(sampleUp.xyz);
float valueBottom = avg(sampleDown.xyz);

float4 diffToCenter = valueCenter - float4(valueLeft, valueTop, valueRight, valueBottom);
float blurAmountLeft = saturate( 0.0 + ( valueVertLong - valueLeft ) / diffToCenter.x );
float blurAmountUp = saturate( 0.0 + ( valueHorizLong - valueTop ) / diffToCenter.y );
float blurAmountRight= saturate( 1.0 + ( valueVertLong - valueCenter ) / diffToCenter.z );
float blurAmountDown = saturate( 1.0 + ( valueHorizLong - valueCenter ) / diffToCenter.w );

float4 blurAmounts = float4( blurAmountLeft, blurAmountRight, blurAmountUp, blurAmountDown );
blurAmounts = (blurAmounts == float4(0.0, 0.0, 0.0, 0.0)) ? float4(1.0, 1.0, 1.0, 1.0) : blurAmounts;

float4 longBlurHoriz = lerp( sampleLeft, sampleCenter, blurAmounts.x );
longBlurHoriz = lerp( sampleRight, longBlurHoriz, blurAmounts.y );
float4 longBlurVert = lerp( sampleUp, sampleCenter, blurAmounts.z );
longBlurVert = lerp( sampleDown, longBlurVert, blurAmounts.w );

aaResult = lerp( aaResult, longBlurHoriz, pass1EdgeAvgVert);
aaResult = lerp( aaResult, longBlurVert, pass1EdgeAvgHoriz);
}

return float4(aaResult.rgb, 1.0f);
}


*/