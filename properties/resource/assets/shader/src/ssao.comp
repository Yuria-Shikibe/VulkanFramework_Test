#version 460
#pragma shader_stage(compute)

#define MaxKernalSize 64

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform UBO {
    vec4 kernal[MaxKernalSize];
    uint kernalSize;
} ubo;

layout(binding = 1) uniform sampler2D depthTex;
layout(binding = 2, rgba32f) uniform image2D outTex;

layout(set = 0, binding = 3) uniform UBOScale {
    float scale;
};

const float radius = 16.f;
const float zDiffScl = 1.8f;
const float zDiffThreshold = 0.05f;

void main() {
    float occlusion = 0.0;

    const  ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    const  vec2 uv = (vec2(pos) + vec2(0.5f, 0.5f)) / vec2(imageSize(outTex));

    const float depth = texture(depthTex, uv).x;

    for (uint i = 0; i < ubo.kernalSize; ++i){
        // get smp position
        const vec2 smp = uv + ubo.kernal[i].xy * radius * scale;// From tangent to view-space

        const float sampleDepth = texture(depthTex, smp).x;// Get depth value of kernel smp

        if(sampleDepth >= depth)continue;

        const float rangeCheck = smoothstep(zDiffThreshold, 1.0, radius / abs(depth - sampleDepth) * zDiffScl);
        occlusion += rangeCheck;
    }

    const float factor = max(occlusion, 0) / ubo.kernalSize;
    const float drakness = 1.0 - factor;

    const vec4 outColor = vec4(vec3(smoothstep(0.25f, 1.f, drakness)), factor);

    imageStore(outTex, pos, outColor);
}